<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Geoffrey Hadfield">
<meta name="dcterms.date" content="2025-03-24">

<title>Capstone Project: Modeling Fatigue and Injury Risk in Athletic Movements like Basketball Shooting – Modeling Fatigue and Injury Risk in Baseball Pitching</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b4406b7675125bc2ba204020e191172.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-bb5f9278568ae542f8467bdb635b70ac.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Modeling Fatigue and Injury Risk in Baseball Pitching</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./slides.html"> 
<span class="menu-text">Presentation</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-notebooks" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Notebooks</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-notebooks">    
        <li>
    <a class="dropdown-item" href="./final_notebooks/lstm_rnn_energy_predict_granular_dataset_final_project.html">
 <span class="dropdown-text">LSTM RNN Energy Prediction</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/ghadfield32/emg_fatigue_analysis" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#lstm-long-short-term-memory-networks" id="toc-lstm-long-short-term-memory-networks" class="nav-link" data-scroll-target="#lstm-long-short-term-memory-networks">LSTM (Long Short-Term Memory) Networks</a></li>
  <li><a href="#preprocessing-approaches" id="toc-preprocessing-approaches" class="nav-link" data-scroll-target="#preprocessing-approaches">Preprocessing Approaches</a></li>
  </ul></li>
  <li><a href="#data-description" id="toc-data-description" class="nav-link" data-scroll-target="#data-description">Data Description</a>
  <ul class="collapse">
  <li><a href="#features-x-metrics" id="toc-features-x-metrics" class="nav-link" data-scroll-target="#features-x-metrics">Features (X metrics)</a></li>
  <li><a href="#target-variables-y-metrics" id="toc-target-variables-y-metrics" class="nav-link" data-scroll-target="#target-variables-y-metrics">Target Variables (Y metrics)</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  </ul></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">EXAMPLE:</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Capstone Project: Modeling Fatigue and Injury Risk in Athletic Movements like Basketball Shooting</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Geoffrey Hadfield </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 24, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Fatigue and injury risk modeling are essential components of modern sports analytics, especially for basketball athletes. Accurately predicting fatigue levels and injury risks can significantly optimize training, enhance performance, and prolong athlete careers. Long Short-Term Memory (LSTM) networks—a specialized type of Recurrent Neural Network (RNN)—are well-suited to capturing sequential and temporal patterns inherent in physiological and biomechanical athlete data.</p>
<p>Recent studies underline the critical link between fatigue accumulation and increased injury risk, emphasizing the need for precise temporal modeling. This capstone project employs LSTM models to forecast fatigue levels (<code>exhaustion_rate</code>) and classify joint injury risks (<code>injury_risk</code>) during basketball shooting trials. The goal is to support injury prevention strategies and optimize athletic performance using biomechanical and physiological insights.</p>
<p>Key literature informing this approach:</p>
<ul>
<li><strong>Athlete Burnout:</strong> Individualized factors (stress, training load, recovery support) significantly influence injury risks, suggesting the need for personalized interventions.</li>
<li><strong>Fatigue Data Collection:</strong> Datasets capturing muscle activity, biomechanics, and physiological fatigue indicators serve as foundational resources.</li>
<li><strong>Methodological Advances:</strong>
<ul>
<li>Fatigue modeling using neural networks: <a href="https://doi.org/10.1016/j.engfracmech.2020.107402">DOI: 10.1016/j.engfracmech.2020.107402</a><br>
</li>
<li>Injury risk forecasting via combined metrics: <a href="https://doi.org/10.52082/jssm.2024.537">DOI: 10.52082/jssm.2024.537</a></li>
</ul></li>
</ul>
<hr>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="lstm-long-short-term-memory-networks" class="level3">
<h3 class="anchored" data-anchor-id="lstm-long-short-term-memory-networks">LSTM (Long Short-Term Memory) Networks</h3>
<p>LSTMs effectively address issues of vanishing gradients typical in traditional RNNs. Their gating mechanisms enable capturing long-term dependencies crucial in sequential physiological and biomechanical data:</p>
<ul>
<li><p><strong>Forget Gate:</strong><br>
<span class="math display">\[f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)\]</span></p></li>
<li><p><strong>Input Gate:</strong><br>
<span class="math display">\[i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)\]</span><br>
<span class="math display">\[\tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C)\]</span></p></li>
<li><p><strong>Cell State Update:</strong><br>
<span class="math display">\[C_t = f_t \odot C_{t-1} + i_t \odot \tilde{C}_t\]</span></p></li>
<li><p><strong>Output Gate:</strong><br>
<span class="math display">\[o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)\]</span><br>
<span class="math display">\[h_t = o_t \odot \tanh(C_t)\]</span></p></li>
</ul>
<p><em>(</em>where ( W ) and ( b ) represent weights and biases, ( ) is the sigmoid function, and ( ) denotes element-wise multiplication.<em>)</em></p>
</section>
<section id="preprocessing-approaches" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing-approaches">Preprocessing Approaches</h3>
<ul>
<li>Evaluating optimal sequence handling via:
<ul>
<li><strong>Dynamic Time Warping (DTW)</strong></li>
<li><strong>Padding sequences</strong></li>
<li><strong>Windowing methods</strong> (<code>set_window</code>)</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="data-description" class="level2">
<h2 class="anchored" data-anchor-id="data-description">Data Description</h2>
<p>The SPL Open Biomechanics dataset provides biomechanical and simulated physiological data from <strong>125 basketball shooting trials</strong>.</p>
<section id="features-x-metrics" class="level3">
<h3 class="anchored" data-anchor-id="features-x-metrics">Features (X metrics)</h3>
<ul>
<li><strong>Joint Metrics:</strong>
<ul>
<li><strong>Joint Energy:</strong> Joules (range: 50–250 J)<br>
</li>
<li><strong>Joint Power:</strong> Watts (range: 100–1000 W)</li>
</ul></li>
<li><strong>Simulated Physiological Metrics:</strong>
<ul>
<li><strong>Simulated Heart Rate:</strong> beats per minute (range: 60–180 bpm)<br>
</li>
<li><strong>Simulated wearable metrics:</strong> sleep quality/duration, resting heart rate, HR variability, stress index</li>
</ul></li>
<li><strong>Temporal Dynamics:</strong>
<ul>
<li><strong>Exhaustion Rate per trial:</strong> rate of exhaustion accumulation<br>
</li>
<li><strong>Rolling averages and lagged exhaustion features</strong></li>
</ul></li>
<li><strong>Asymmetry Features:</strong>
<ul>
<li><strong>Left/right joint energy and power differences:</strong> (range: -50 to 50 J)</li>
</ul></li>
<li><strong>Physical Traits (categorical handling):</strong>
<ul>
<li><strong>Player Height</strong><br>
</li>
<li><strong>Player Weight</strong></li>
</ul></li>
</ul>
</section>
<section id="target-variables-y-metrics" class="level3">
<h3 class="anchored" data-anchor-id="target-variables-y-metrics">Target Variables (Y metrics)</h3>
<ul>
<li><p><strong>Regression target (<code>exhaustion_rate</code>):</strong><br>
Measures how rapidly fatigue accumulates over time—more actionable than the snapshot-style <code>by_trial_exhaustion_score</code>.</p>
<p>```python data[‘exhaustion_rate’] = data[‘by_trial_exhaustion_score’].diff() / data[‘by_trial_time’].diff()</p>
<p>Classification target (injury_risk): A binary flag indicating risk moments when rolling exhaustion surpasses the 75th percentile threshold.</p></li>
</ul>
<p>data[‘injury_risk’] = (data[‘rolling_exhaustion’] &gt; safe_expanding_quantile(data[‘rolling_exhaustion’])).astype(int)</p>
<p>def safe_expanding_quantile(s): return s.expanding().quantile(0.75).shift().fillna(0)</p>
<p>Energy Calculations:</p>
<pre><code>def calculate_by_trial_energy(df, energy_columns, debug=False):
    df['by_trial_energy'] = df.groupby('trial_id')['total_energy'].cumsum()
    df['by_trial_exhaustion_score'] = df.groupby('trial_id')['by_trial_energy'].transform(lambda x: x / x.max())
    return df</code></pre>
<p>Analysis and Results Descriptive Statistics Variable Type Mean Std Dev Min Max joint_energy float64 1.346 0.914 0.000 49.116 joint_power float64 20.153 12.503 0.000 60.832 energy_acceleration float64 -11458.532 133306.500 -2189662.00 0.073 hip_asymmetry float64 0.004 0.007 0.000 0.185 wrist_asymmetry float64 0.022 0.022 0.000 0.244 rolling_power_std float64 3.350 3.234 0.061 17.384 rolling_hr_mean float64 61.079 0.516 60.091 63.641 rolling_energy_std float64 0.203 0.389 0.002 19.404 simulated_HR float64 61.079 0.550 60.000 75.117 player_height_in_meters float64 1.910 0.000 1.910 1.910 player_weight_in_kg float64 90.700 0.000 90.700 90.700 by_trial_exhaustion_score float64 0.450 0.267 0.000 1.000 injury_risk int32 0.275 0.446 0.000 1.000 Multicollinearity Assessment &amp; Feature Selection Highly Correlated Features (Action Taken)</p>
<pre><code>Joint Energy vs Joint Power (corr = 0.909506):

    Action: Retain joint_energy for both regression and classification due to consistently higher importance.

Rolling HR Mean vs Simulated HR (corr = 0.919149):

    Regression (exhaustion_rate): Retain simulated_HR (higher importance).

    Classification (injury_risk): Retain rolling_hr_mean (higher importance).</code></pre>
<p>Correlation &amp; Feature Importance Visualizations</p>
<p>Correlation Matrix <img src="images/corr_matrix.png" alt="Correlation matrix for LSTM Regression y_var= by_trial_exhaustion_score and injury_risk" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Feature Importance: Injury Risk</p>
<p>SHAP Importance: <img src="images/shap_importance_injury_risk.png" alt="Perm and SHAP importance for Regression Model Forecasting Injury Risk" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Permutation Importance: <img src="images/permutation_importance_injury_risk.png" alt="Perm and SHAP importance for Regression Model Forecasting Injury Risk" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Feature Importance: Exhaustion Rate</p>
<p>SHAP Importance: <img src="images/shap_importance_exhaustion_rate.png" alt="Perm and SHAP importance for Regression Model Forecasting Exhaustion Rate" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Permutation Importance: <img src="images/permutation_importance_exhaustion_rate.png" alt="Perm and SHAP importance for Regression Model Forecasting Exhaustion Rate" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Data Visualizations</p>
<p>Histogram Distributions for Joint Metrics: <img src="images/histograms.png" alt="Joint Histograms" style="width:100%; display:block; margin: 0 auto;"></p>
<p>Scatter Plots (Physiological Metrics vs Fatigue Rates): <img src="images/scatter_plot_exhaustion_score.png" alt="Joint by Exhaustion Rate Scatter Plot" style="width:100%; display:block; margin: 0 auto;"></p>
<section id="modeling-and-results" class="level5">
<h5 class="anchored" data-anchor-id="modeling-and-results">Modeling and Results</h5>
<p>Steps: Explain your data preprocessing and cleaning steps.</p>
<pre><code>Present your key findings in a clear and concise manner.

Use visuals to support your claims.

Tell a story about what the data reveals.</code></pre>
<p>work below—————-</p>
<p>Predictive Modeling Pipelines Pipeline 1: Regression for Predicting Trial Exhaustion Rate</p>
<p>Input Features: Aggregated joint metrics, simulated physiological features, and temporal features.</p>
<p>Model: A baseline linear regression model is used, with future plans to incorporate Random Forests, Gradient Boosting, or LSTM networks.</p>
<p>Evaluation: Model performance is assessed using Mean Absolute Error (MAE), Root Mean Squared Error (RMSE), and R², along with visualizations comparing predicted versus actual exhaustion rates.</p>
<p>Pipeline 2: Classification for Predicting Joint Injury Risk</p>
<p>Input Features: Joint-specific metrics, asymmetry measurements, and cumulative load indicators.</p>
<p>Labeling: Trials are classified as high injury risk if a rolling sum of joint stress exceeds a threshold (e.g., the 75th percentile).</p>
<p>Model: Initially, logistic regression or decision tree classifiers are employed. Future work may involve Random Forests or neural network-based methods.</p>
<p>Evaluation: Metrics such as accuracy, precision, recall, F1-score, and ROC-AUC are used, supplemented by feature importance analyses using SHAP values.</p>
<p>Integration and Modularity</p>
<p>Both pipelines share common preprocessing and feature engineering modules, ensuring that the workflow is modular and reproducible. Visualization tools—including histograms, correlation matrices, and temporal trend plots—are used throughout the analysis to validate each transformation step. Experimental Results</p>
<p>The LSTM-based regression model for fatigue prediction demonstrated promising results:</p>
<p>MSE: 0.00596</p>
<p>MAE: 0.01762</p>
<p>R² Score: 0.91808</p>
<p>Similarly, the injury risk classifier achieved strong performance:</p>
<p>Overall Accuracy: 98.16%</p>
<p>Precision: 93.84%</p>
<p>Recall: 99.77%</p>
<p>F1 Score: 96.72%</p>
</section>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>Steps: Summarize your key findings.</p>
<pre><code>Discuss the implications of your results.</code></pre>
<p>—–work below:</p>
<p>Joint-specific models yielded varying metrics, reflecting the inherent complexity of localized biomechanical data. Discussion</p>
<p>This project illustrates the successful application of deep learning to model fatigue and predict injury risk in a real-world sports setting. Key challenges included managing the variability in biomechanical signals and optimizing model performance through careful feature engineering. The integration of temporal dynamics and asymmetry features was critical in capturing the underlying physiological responses. Future work may explore attention mechanisms or hybrid architectures to further refine predictive accuracy. Conclusion</p>
<p>By combining real athlete data with simulated physiological metrics, this capstone project provides a novel approach to predicting fatigue and injury risks in basketball players. The dual-pipeline strategy (regression and classification) along with modular integration of preprocessing and feature engineering modules establishes a robust framework that is transparent, reproducible, and adaptable for future research and practical deployment. References</p>
</section>
<section id="resources" class="level3">
<h3 class="anchored" data-anchor-id="resources">Resources</h3>
<p>DataCamp Tutorial: Introduction to SHAP Values for Machine Learning Interpretability</p>
<p>DataCamp Tutorial: Mastering Bayesian Optimization in Data Science</p>
<p>Fatigue Analysis Study, DOI: 10.1016/j.engfracmech.2020.107402</p>
<p>Injury Prediction Study, DOI: 10.52082/jssm.2024.537</p>
<p>Nature Articles:</p>
<pre><code>Factors Leading to Athlete Burnout

Dataset for Fatigue Analysis during Shoulder Rotations</code></pre>
</section>
</section>
<section id="example" class="level2">
<h2 class="anchored" data-anchor-id="example">EXAMPLE:</h2>
<p>Writing a great story for data science projects - spring 2025</p>
<p>This is a Report Template Quarto Author</p>
<p>Students names (Advisor: Dr.&nbsp;Cohen) Published</p>
<p>January 14, 2025</p>
<p>Slides: slides.html ( Go to slides.qmd to edit) Important</p>
<p>Remember: Your goal is to make your audience understand and care about your findings. By crafting a compelling story, you can effectively communicate the value of your data science project.</p>
<p>Carefully read this template since it has instructions and tips to writing! Introduction</p>
<p>The introduction should:</p>
<pre><code>Develop a storyline that captures attention and maintains interest.

Your audience is your peers

Clearly state the problem or question you’re addressing.

Introduce why it is relevant needs.

Provide an overview of your approach.</code></pre>
<p>Example of writing including citing references:</p>
<p>This is an introduction to ….. regression, which is a non-parametric estimator that estimates the conditional expectation of two variables which is random. The goal of a kernel regression is to discover the non-linear relationship between two random variables. To discover the non-linear relationship, kernel estimator or kernel smoothing is the main method to estimate the curve for non-parametric statistics. In kernel estimator, weight function is known as kernel function (Efromovich 2008). Cite this paper (Bro and Smilde 2014). The GEE (Wang 2014). The PCA (Daffertshofer et al.&nbsp;2004). Topology can be used in machine learning (Adams and Moy 2021)</p>
<p>This is my work and I want to add more work… Methods</p>
<pre><code>Detail the models or algorithms used.

Justify your choices based on the problem and data.</code></pre>
<p>The common non-parametric regression model is , where can be defined as the sum of the regression function value for . Here is unknown and some errors. With the help of this definition, we can create the estimation for local averaging i.e.&nbsp;can be estimated with the product of average and is near to</p>
<p>. In other words, this means that we are discovering the line through the data points with the help of surrounding data points. The estimation formula is printed below (R Core Team 2019):</p>
<p>is the sum of weights that belongs to all real numbers. Weights are positive numbers and small if is far from</p>
<p>.</p>
<p>Another equation:</p>
<p>Analysis and Results Data Exploration and Visualization</p>
<pre><code>Describe your data sources and collection process.

Present initial findings and insights through visualizations.

Highlight unexpected patterns or anomalies.</code></pre>
<p>A study was conducted to determine how… Code</p>
<p>Code</p>
<p>state abb region population total Alabama AL South 4779736 135 Alaska AK West 710231 19 Arizona AZ West 6392017 232 Arkansas AR South 2915918 93 California CA West 37253956 1257 Colorado CO West 5029196 65 Code</p>
<p>Modeling and Results</p>
<pre><code>Explain your data preprocessing and cleaning steps.

Present your key findings in a clear and concise manner.

Use visuals to support your claims.

Tell a story about what the data reveals.</code></pre>
<p>Conclusion</p>
<pre><code>Summarize your key findings.

Discuss the implications of your results.</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>